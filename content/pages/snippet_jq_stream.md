---
title: 'jq --stream: jq で大きなファイルを処理する'
draft: true
---

非常に大きなファイル、例えば 1G を超えるようなログファイルを
jq を使ってパースする際には工夫が必要です。

単純に jq にファイルを与えてしまうと、非常に多くのメモリが使われてしまい、動作が遅くなってしまします。
これは、 jq が *最初に、完全に JSON をパースしようとする* ためです。

そこで jq には `--stream` オプションが用意されています。
このオプションを使用すると、jq は JSON を逐次的にパースしていきます。

以下に jq の man から抜粋します。

```
       o   --stream:

           Parse  the  input  in streaming fashion, outputing arrays of path
           and leaf values (scalars and empty arrays or empty objects).  For
           example,   "a"   becomes  [[],"a"],  and  [[],"a",["b"]]  becomes
           [[0],[]], [[1],"a"], and [[1,0],"b"].

           This is useful for processing very large inputs. Use this in con-
           junction  with  filtering  and  the  reduce and foreach syntax to
           reduce large inputs incrementally.
```

`--stream` オプションをつけた場合、通常の jq でのパース結果と違い、
解析されたパスと値が、`[<パス>, <値>]` または `[<パス>]` という形式で順次出力されます。
`[<パス>, <値>]` は JSON 上のパスと値、各種スカラー値や空の配列、からのオブジェクトを提示するのに用いられ、
また、 `[<パス>]` は配列・オブジェクトの終端を示すのに用いられます。
通常の jq での出力結果とかなり違うので、少々注意が必要です。

分かりにくいので、まずは出力例を示しましょう。

例えば `"a"` を jq にかけると、以下のようになります

````
# 通常のパース結果
$ echo '"a"' | jq .
"a"

# stream のパース結果
$ echo '"a"' | jq --stream
[
  [],
  "a"
]
```

この出力は、 `[]` つまりルートの値が `"a"` だったということを示しています。

複数の要素がある場合を見ていきましょう。
`[0, [1]]` は以下のよう4つの結果として出力されます。
(結果が複数行になるので `--compact-output` オプションもつけて、１行ずつ表示するようにします)

```
# 通常のパース結果
$ echo '[0,[1]]' | jq .
[
  0,
  [
    1
  ]
]

# stream のパース結果
$ echo '[0,[1]]' | jq --stream --compact-output
[[0],0]
[[1,0],1]
[[1,0]]
[[1]]
```

最初の `[[0], 0]` で、ルートが配列であり、その 0 番目の要素が 0 であることを示しています。
次に `[[1, 0], 1]` で、ルートの配列の 1 番目の要素が配列であり、その 0 番目の要素が 1 であることが示されています。
`[[1, 0]]` はルートの配列の 1 番目の要素の配列が終了したことを、
`[[1]]` は、ルートの配列が終了したことを示しています。

より、実践的な形として以下を見ていきましょう。

```
# 通常のパース結果
$ echo '{"a": 1234, "b": 9876, "c": { "key": "val1" } }\n{"a": 47, "b": 0, "c": { "key": "val2" }  }' | jq .
{
  "a": 1234,
  "b": 9876,
  "c": {
    "key": "val1"
  }
}
{
  "a": 47,
  "b": 0,
  "c": {
    "key": "val2"
  }
}

# stream のパース結果
$ echo '{"a": 1234, "b": 9876, "c": { "key": "val1" } }\n{"a": 47, "b": 0, "c": { "key": "val2" }  }' | jq --stream --compact-output
[["a"],1234]
[["b"],9876]
[["c","key"],"val1"]
[["c","key"]]
[["c"]]
[["a"],47]
[["b"],0]
[["c","key"],"val2"]
[["c","key"]]
[["c"]]
```

`[["a"],1234]` はルート要素がオブジェクトであり、キー "a" の値が 1234 であることを示しています
`[["b"],9876]` はルート要素がオブジェクトであり、キー "b" の値が 9876 であることを示しています
`[["c","key"],"val1"]` はルート要素がオブジェクトであり、キー "c" の値オブジェクトであり、キー "key" の値が "val1" であることを示しています
`[["c","key"]]` はルート要素がオブジェクトであり、キー "c" の値がオブジェクトであり、キー "key" で終了することを示しています
`[["c"]]` はルート要素がオブジェジェクトであり、キー "c" で終了することを示しています
`[["a"],47]` は2番目のルート要素がオブジェクトであり、キー "a" の値が 47 であることを示しています
`[["b"],0]` は2番目のルート要素がオブジェクトであり、キー "b" の値が 0 であることを示しています
`[["c","key"],"val2"]` は2番目のルート要素がオブジェクトであり、キー "c" の値オブジェクトであり、キー "key" の値が "val2" であることを示しています
`[["c","key"]]` は2番目のルート要素がオブジェクトであり、キー "c" の値がオブジェクトであり、キー "key" で終了することを示しています
`[["c"]]` は2番目のルート要素がオブジェジェクトであり、キー "c" で終了することを示しています

以上のように、通常の jq での出力とは大分ことなりますので注意が必要です

## select と組み合わせてフィルタする

さて、具体的な使用例を見ていきましょう。

例えば、以下のような構造の JSON があったとします。
最初にメタデータとして全件の件数や、現在のページ数などが JSON 

```javascript
{
  "total": 3000,
  "page": 3,
  "per_page": 100,
  "content": [
    {
      "title": "Lorem Ipsum",
      "body": "lorem ipsum....",
    },
    ...
  ]
}
```

例えば、この JSON からタイトルのみを取り出したい場合、通常の jq であれば以下のように取得します

```
$ jq '.content[].title'
```

--stream の場合は

```
$ jq 'select(.[0][0] == "content" and .[0][2] == "title") | .title'
```




## 組み込み関数

### truncate_stream



### fromstream

### tostream


