<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>これはタイトルです | ayasuda.github.io</title><meta name=keywords content><meta name=description content="俺のための yacc 入門 いつか何もかも忘れる自分に向けて。 この文書では、yacc って何？ 美味しいの？ みたいなプログラマ、そうオレをターゲットに、 ステ"><meta name=author content="ayasuda"><link rel=canonical href=https://ayasuda.github.io/pages/introduction_yacc/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ayasuda.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayasuda.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayasuda.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayasuda.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayasuda.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-138223597-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="これはタイトルです"><meta property="og:description" content="俺のための yacc 入門 いつか何もかも忘れる自分に向けて。 この文書では、yacc って何？ 美味しいの？ みたいなプログラマ、そうオレをターゲットに、 ステ"><meta property="og:type" content="article"><meta property="og:url" content="https://ayasuda.github.io/pages/introduction_yacc/"><meta property="article:section" content="pages"><meta property="og:site_name" content="ayasuda.gihtub.io"><meta name=twitter:card content="summary"><meta name=twitter:title content="これはタイトルです"><meta name=twitter:description content="俺のための yacc 入門 いつか何もかも忘れる自分に向けて。 この文書では、yacc って何？ 美味しいの？ みたいなプログラマ、そうオレをターゲットに、 ステ"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Pages","item":"https://ayasuda.github.io/pages/"},{"@type":"ListItem","position":3,"name":"これはタイトルです","item":"https://ayasuda.github.io/pages/introduction_yacc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"これはタイトルです","name":"これはタイトルです","description":"俺のための yacc 入門 いつか何もかも忘れる自分に向けて。 この文書では、yacc って何？ 美味しいの？ みたいなプログラマ、そうオレをターゲットに、 ステ","keywords":[],"articleBody":"俺のための yacc 入門 いつか何もかも忘れる自分に向けて。\nこの文書では、yacc って何？　美味しいの？　みたいなプログラマ、そうオレをターゲットに、 ステップバイステップで yacc の使い方 について学んでいく。\nyacc yacc (yet another compiler compiler) は構文解析器を作るためのツールです。\n構文解析器って何よ？ 大雑把に言えばプログラミング言語みたいな一定のルールを守った言語のことを 「 形式言語 」と呼びます。 そんな形式言語で書かれた文書を元に、構文木を作るツールが構文解析器です。\n一般的に、コンパイラは字句解析器 (lexical analyzer, lexier) が字句解析をし、字句の列を作ります。 次に構文解析器 (parser) が字句の列を元に、構文木を作ります。 そして、最後にその構文木を元に計算を行う奴がいたり、もしくは実行可能なマシン語に変換する奴がいたりします。\nyacc はこの構文解析器を作るためのツールになります。\n準備 まずは yacc または、bison をインストールしましょう。\nインストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。\n$ yacc --version bison (GNU Bison) 2.3 Written by Robert Corbett and Richard Stallman. Copyright (C) 2006 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. また、 yacc は定義ファイルを元に C のコードを生成します。 ですので、 C のコンパイラをインストールしておく必要があります。\nインストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。\n$ cc --version Apple LLVM version 8.0.0 (clang-800.0.42.1) Target: x86_64-apple-darwin15.6.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin あとあと、どうせ使うことになるので lex または flex もインストールしておきます。 lex は字句解析器を作るためのツールとなります。 インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。\n$ lex --version flex 2.5.35 Apple(flex-31) ついでに make もインストールしておくと便利です。 インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。\n$ make --version GNU Make 3.81 Copyright (C) 2006 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. This program built for i386-apple-darwin11.3.0 初めての(何も起きない)構文解析器 - まずはいつもの Hello,World. から まずは作業用のディレクトリを作り、そこに移動しましょう。\n$ mkdir minimal $ cd minimal 早速、“Hello, World.” と表示されるだけのプログラムを書いてみましょう。 構文解析器の定義ファイルである minimal.y を次のように書きます。\n%{ #include int yyerror(const char *s); int yylex(void); %} %% PROGRAM : ; %% int main() { yyparse(); printf(\"Hello, World.\\n\"); return 0; } int yyerror(const char *s) { return 0; } int yylex(void) { return 0; } 書けたら早速動かしてみましょう。まずは yacc を用いて C のコードを生成します。 この時、何も指定しなければ y.tab.c というファイルが生成されるはずです。 次に、この C のコードをコンパイルして実行可能にします。 コンパイルができたら、動かしてみて、 “Hello,World.” と表示されるのを確認しましょう。\n$ yacc minimal.y $ cc y.tab.c $ ./a.out Hello, World. 定義ファイルの構造 yacc で用いる定義ファイルは宣言部、定義部、プログラム部の 3 部で構成され、それぞれ %% で区切られます。\n/* 宣言部 */ %% /* 定義部 */ %% /* プログラム部 */ このうち、宣言部及びプログラム部は省略が可能です。\n宣言部では使用する字句の宣言や全体で使う C の対局変数定義、関数の宣言などを行います。 定義部には構文解析で用いる、構文規則(文法の定義)を、そしてプログラム部では C の関数実装などを行います。\n先ほど作った minimal.y を見ていきましょう。\n宣言部では、全体で使うために stdio.h のインクルードをしています。 定義部には構文規則が書かれておりますが、今回は特に使わないので意味のない文法が定義されています。 最後にプログラム部ではエントリーポイントである main 関数及び、 yacc が字句解析のために要求する yylex 関数、 そしてエラー処理のために要求する yyerror 関数の実装が書かれています。\n定義ファイルの書き方 構文規則 定義部には構文解析に用いる構文規則を書いていきます。 構文規則は以下の形式で定義します。\na : body ; ここで、 a は文法の名前(非終端記号)で、 body はそれの構成要素です。 具体例として、「日付」の定義を見てみましょう。\ndate : year '/' month '/' day ; この構文規則では、次のような書式を「日付」として扱うと定義しています。\n「日付」は、まず「年」があり、次に ‘/’ があり、次に「月」があり、次に ‘/’ があり、最後に「日」が書かれている物である\nこのような構文規則を定義することで、例えば “2017/10/21” のような文字列が「日付」として処理されるようになります。\nところで、上記のような定義を見ると、year とか、 month とかも構文規則が必要になることに気づくかと思います。 その通りで、どんどんどんどん構文規則を定義していくと、最後は「文字」とか、「記号」とかのレベルまで分解可能です。 逆に言えば、「文字」とか「記号」とかは特に定義をする必要がありません。このように、構文規則の右側にのみ現れる記号を 「終端記号」といい、構文規則として定義される記号を「非終端記号」と呼びます。 「日付」の例で言えば、 year や day は非終端記号であり、別に構文規則の定義がされます。 一方、 '/' はスラッシュ記号そのものであり、定義はされません。つまり終端記号です。\n構文規則の選択 さて、世の中には同じ記号を複数の構文規則で定義したい場合があります。 例えば、 “2017/10/21” も “2017-10-21” も「日付」として扱いたい場合などです。\nこの場合、yaccの構文規則では、次のように並べて書くことができます。\ndate : year '/' month '/' day ; date : year '-' month '-' day ; また、バー | を使うことで、より変更しやすく、見やすく書くこともできます。\ndate : year '/' month '/' day | year '-' month '-' day ; 再帰的な定義 再帰的に構文規則を定義することで柔軟な文法を定義することができるのも特徴です。 例えば “1,2” も “1,2,3” も「リスト」として扱いたいみたいな場合は、次のように定義します。 (item は [0-9]+ とする)\nlist : item | item list ; この規則 2 である item list がミソです。\nまず、規則 1 により、 item は list です。 よって、規則 2 より、item item も list になります。 よって、規則 2 より、item item item も list になります。 と、このように、再帰的に定義が可能となります。\n構文規則とアクション 構文規則だけを定義し続けても、「だから？」みたいな気分になること請け合いです。 何らかの処理と関連付けないと意味がありません。 yacc では、構文規則とアクションを関連付けることができます。\nアクションは任意の C のコードで、構文規則の次にブレース {} で囲って定義します。\nA : '(' B ')' { foo(47, \"bar\") } ; 文法に基づいて文を解析しやすくするように、アクション中で次の疑似変数を使うことができます。\nアクション中で値を返すためには $$ を使います。\n{ $$ = 47; } 構成要素から値を取得するためには $1, $2, ... を使います。\n{ printf(\"%d\\n\", $1); } 例を見てみましょう。\nA : B C { printf(\"%d\\n\", ($1 + $2)); } ; B : ',' { $$ = 3 } ; C : '.' { $$ = 5 } ; こちらの定義では、 B が 3 を返し、C が 5 を返します。 返した値は、その定義を使う A で利用でき、A のアクション内では、 $1, $2, ... から使うことができます。 この $ の次につく数値は、構文定義の構成要素として現れる順に振られます。 ですので、上記の例では $1 が 3 に、 $2 が 5 になります。\nこれを用いたサンプルを最後に一つお見せしましょう。\nexpression : '(' expression ')' { $$ = $2 } この定義は次のようになります。\n「式」は ‘()’ でくくっても、「式」\n字句解析の定義 最初の方にも書きましたが、一般的なコンパイラでは字句解析器が字句解析をし、 それによって得られた字句の集合を元に構文解析器が構文解析をします。 そして、yacc は構文解析器を作るツールです。\nですので、yacc は字句解器をする関数 int yylex(void); という関数の実装を要求します。\nint yylex(void); はユーザからの入力を字句(token)に分解し、パーサに結果を渡す関数です。 この関数は字句の種類を表す字句番号を整数でで返し、トークンに関連付けられた値がある場合は外部変数の yylval に割り当てます。\nさて、この int yylex(void); は自作可能ですが、少なくとも入門者が自作するのは無謀なので、 字句解析器を作るためのツールである lex を使います。\n字句解析器の生成ツール lex との連携 直前にも書きましたが、yacc は字句解器をする関数 int yylex(void); という関数の実装を要求します。 そして、その関数は自作可能ですが、入門者ならば lex を使い自動生成した方が簡単です。\nlex は字句解析器を作るためのツールです。\nlex も yacc と似ており、字句解析器の定義ファイルを lex に渡してやることで、 字句解析器の C ソースファイル(デフォルトでは lex.yy.c )が作成されます。\n$ ls minimal.l $ lex minimal.l $ ls minimal.l lex.yy.c また、定義ファイルの構成も似ており、宣言部、定義部、プログラム部の 3 部で構成され、それぞれ %% で区切られます。\n/* 宣言部 */ %% /* 定義部 */ %% /* プログラム部 */ lex で定義するのは字句解析器向けのルールになるので、定義部は yacc で用いる定義ファイルと異なります。 lex で定義する字句解析ルールの書き方は簡単で、まずマッチさせるための正規表現を書き、次にアクションを書くだけです。 アクションは C のプログラムコードで書き、1文ならそのまま、2文以上なら {} で囲んで書きます。\nサンプルとして、単語数を数える字句解析器のコードを見ながら説明しましょう。\n%option noyywrap %{ int num_lines = 0, num_words = 0, num_chars = 0; %} %% \\n { ++num_lines; } [a-zA-Z0-9]* { ++num_words; } . { ++num_chars; } %% int main(void) { yylex(); printf(\"# of lines = %d, # of words = %d # of chars = %d\\n\", num_lines, num_words, num_chars); } この定義ファイルを元に字句解析器を作り、動かしてみると(精度はイマイチですが)きちんと動くのがわかるかと思います。\n$ lex mywc.l $ cc lex.yy.c $ cat mywc.l | ./a.out # of lines = 17, # of words = 42 # of chars = 133 さて、この lex を使って yacc 向けの int yylex(void); 関数を実装するわけですが、 この時、上記に示した lex 単体で動くプログラム、 mywc.l と次の3点を変える必要があります。\nlex 向けのオプション noyywrap を消す (要調査) lex のアクションで字句名を返すようにする lex と yacc で同じ字句名を使えるように、 lex 側で y.tab.h (yacc の生成するヘッダ) を読み込む サンプルとして、入力中から日付だけを抜き出すプログラムを作ってみましょう。\nまずは作業用ディレクトリを用意します。\n$ mkdir datefinder $ cd datefinder 次に、字句解析器の定義を作っていきます。 字句解析器は、与えられた文字列を、字句ごとにバラバラにするのが目的です。 今回は、与えられた文字列を、「年」「月」「日」「それ以外」に分解していきましょう。\nなお、簡単にするために「月」は英語の省略形 (例えば ‘Jan’) のみを認めることにします。\n%% %% もう少しマシな解析器 - 加算器 yacc の詳細を探りながら、次の話に進みましょう。\n加算・減算器の実装 lex との連携 ","wordCount":"4133","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"ayasuda"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayasuda.github.io/pages/introduction_yacc/"},"publisher":{"@type":"Organization","name":"ayasuda.github.io","logo":{"@type":"ImageObject","url":"https://ayasuda.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ayasuda.github.io accesskey=h title="ayasuda.github.io (Alt + H)">ayasuda.github.io</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ayasuda.github.io/pages/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ayasuda.github.io>Home</a>&nbsp;»&nbsp;<a href=https://ayasuda.github.io/pages/>Pages</a></div><h1 class=post-title>これはタイトルです</h1><div class=post-meta>9 min&nbsp;·&nbsp;4133 words&nbsp;·&nbsp;ayasuda</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#yacc>yacc</a><ul><li><a href=#構文解析器って何よ>構文解析器って何よ？</a></li><li><a href=#準備>準備</a></li></ul></li><li><a href=#初めての何も起きない構文解析器---まずはいつもの-helloworld-から>初めての(何も起きない)構文解析器 - まずはいつもの Hello,World. から</a><ul><li><a href=#定義ファイルの構造>定義ファイルの構造</a></li></ul></li><li><a href=#定義ファイルの書き方>定義ファイルの書き方</a><ul><li><a href=#構文規則>構文規則</a></li><li><a href=#構文規則の選択>構文規則の選択</a></li><li><a href=#再帰的な定義>再帰的な定義</a></li><li><a href=#構文規則とアクション>構文規則とアクション</a></li><li><a href=#字句解析の定義>字句解析の定義</a></li></ul></li><li><a href=#字句解析器の生成ツール-lex-との連携>字句解析器の生成ツール lex との連携</a></li><li><a href=#もう少しマシな解析器---加算器>もう少しマシな解析器 - 加算器</a><ul><li><a href=#加算減算器の実装>加算・減算器の実装</a></li><li><a href=#lex-との連携>lex との連携</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=俺のための-yacc-入門>俺のための yacc 入門<a hidden class=anchor aria-hidden=true href=#俺のための-yacc-入門>#</a></h1><p>いつか何もかも忘れる自分に向けて。</p><p>この文書では、<em>yacc って何？　美味しいの？　みたいなプログラマ、そうオレをターゲットに、
ステップバイステップで yacc の使い方</em> について学んでいく。</p><h2 id=yacc>yacc<a hidden class=anchor aria-hidden=true href=#yacc>#</a></h2><p>yacc (yet another compiler compiler) は構文解析器を作るためのツールです。</p><h3 id=構文解析器って何よ>構文解析器って何よ？<a hidden class=anchor aria-hidden=true href=#構文解析器って何よ>#</a></h3><p>大雑把に言えばプログラミング言語みたいな一定のルールを守った言語のことを
「 <a href=https://ja.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E8%A8%80%E8%AA%9E>形式言語</a> 」と呼びます。
そんな形式言語で書かれた文書を元に、構文木を作るツールが構文解析器です。</p><p>一般的に、コンパイラは字句解析器 (lexical analyzer, lexier) が字句解析をし、字句の列を作ります。
次に構文解析器 (parser) が字句の列を元に、構文木を作ります。
そして、最後にその構文木を元に計算を行う奴がいたり、もしくは実行可能なマシン語に変換する奴がいたりします。</p><p>yacc はこの構文解析器を作るためのツールになります。</p><h3 id=準備>準備<a hidden class=anchor aria-hidden=true href=#準備>#</a></h3><p>まずは yacc または、bison をインストールしましょう。</p><p>インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。</p><pre tabindex=0><code>$ yacc --version
bison (GNU Bison) 2.3
Written by Robert Corbett and Richard Stallman.

Copyright (C) 2006 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre><p>また、 yacc は定義ファイルを元に C のコードを生成します。
ですので、 C のコンパイラをインストールしておく必要があります。</p><p>インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。</p><pre tabindex=0><code>$ cc --version
Apple LLVM version 8.0.0 (clang-800.0.42.1)
Target: x86_64-apple-darwin15.6.0
Thread model: posix
InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
</code></pre><p>あとあと、どうせ使うことになるので lex または flex もインストールしておきます。
lex は字句解析器を作るためのツールとなります。
インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。</p><pre tabindex=0><code>$ lex --version
flex 2.5.35 Apple(flex-31)
</code></pre><p>ついでに make もインストールしておくと便利です。
インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。</p><pre tabindex=0><code>$ make --version
GNU Make 3.81
Copyright (C) 2006  Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.

This program built for i386-apple-darwin11.3.0
</code></pre><h2 id=初めての何も起きない構文解析器---まずはいつもの-helloworld-から>初めての(何も起きない)構文解析器 - まずはいつもの Hello,World. から<a hidden class=anchor aria-hidden=true href=#初めての何も起きない構文解析器---まずはいつもの-helloworld-から>#</a></h2><p>まずは作業用のディレクトリを作り、そこに移動しましょう。</p><pre tabindex=0><code>$ mkdir minimal
$ cd minimal
</code></pre><p>早速、&ldquo;Hello, World.&rdquo; と表示されるだけのプログラムを書いてみましょう。
構文解析器の定義ファイルである minimal.y を次のように書きます。</p><pre tabindex=0><code class=language-yacc:minimal.y data-lang=yacc:minimal.y>%{
#include &lt;stdio.h&gt;
int yyerror(const char *s);
int yylex(void);
%}

%%

PROGRAM : ;

%%

int main()
{
  yyparse();
  printf(&#34;Hello, World.\n&#34;);
  return 0;
}
int yyerror(const char *s) { return 0; }
int yylex(void) { return 0; }
</code></pre><p>書けたら早速動かしてみましょう。まずは yacc を用いて C のコードを生成します。
この時、何も指定しなければ <code>y.tab.c</code> というファイルが生成されるはずです。
次に、この C のコードをコンパイルして実行可能にします。
コンパイルができたら、動かしてみて、 &ldquo;Hello,World.&rdquo; と表示されるのを確認しましょう。</p><pre tabindex=0><code>$ yacc minimal.y
$ cc y.tab.c
$ ./a.out
Hello, World.
</code></pre><h3 id=定義ファイルの構造>定義ファイルの構造<a hidden class=anchor aria-hidden=true href=#定義ファイルの構造>#</a></h3><p>yacc で用いる定義ファイルは宣言部、定義部、プログラム部の 3 部で構成され、それぞれ <code>%%</code> で区切られます。</p><pre tabindex=0><code class=language-yacc data-lang=yacc>/* 宣言部 */
%%
/* 定義部 */
%%
/* プログラム部 */
</code></pre><p>このうち、宣言部及びプログラム部は省略が可能です。</p><p>宣言部では使用する字句の宣言や全体で使う C の対局変数定義、関数の宣言などを行います。
定義部には構文解析で用いる、構文規則(文法の定義)を、そしてプログラム部では C の関数実装などを行います。</p><p>先ほど作った <code>minimal.y</code> を見ていきましょう。</p><p>宣言部では、全体で使うために <code>stdio.h</code> のインクルードをしています。
定義部には構文規則が書かれておりますが、今回は特に使わないので意味のない文法が定義されています。
最後にプログラム部ではエントリーポイントである <code>main</code> 関数及び、
yacc が字句解析のために要求する <code>yylex</code> 関数、
そしてエラー処理のために要求する <code>yyerror</code> 関数の実装が書かれています。</p><h2 id=定義ファイルの書き方>定義ファイルの書き方<a hidden class=anchor aria-hidden=true href=#定義ファイルの書き方>#</a></h2><h3 id=構文規則>構文規則<a hidden class=anchor aria-hidden=true href=#構文規則>#</a></h3><p>定義部には構文解析に用いる構文規則を書いていきます。
構文規則は以下の形式で定義します。</p><pre tabindex=0><code>a : body ;
</code></pre><p>ここで、 a は文法の名前(非終端記号)で、 body はそれの構成要素です。
具体例として、「日付」の定義を見てみましょう。</p><pre tabindex=0><code>date : year &#39;/&#39; month &#39;/&#39; day ;
</code></pre><p>この構文規則では、次のような書式を「日付」として扱うと定義しています。</p><blockquote><p>「日付」は、まず「年」があり、次に &lsquo;/&rsquo; があり、次に「月」があり、次に &lsquo;/&rsquo; があり、最後に「日」が書かれている物である</p></blockquote><p>このような構文規則を定義することで、例えば &ldquo;2017/10/21&rdquo; のような文字列が「日付」として処理されるようになります。</p><p>ところで、上記のような定義を見ると、<code>year</code> とか、 <code>month</code> とかも構文規則が必要になることに気づくかと思います。
その通りで、どんどんどんどん構文規則を定義していくと、最後は「文字」とか、「記号」とかのレベルまで分解可能です。
逆に言えば、「文字」とか「記号」とかは特に定義をする必要がありません。このように、構文規則の右側にのみ現れる記号を
「終端記号」といい、構文規則として定義される記号を「非終端記号」と呼びます。
「日付」の例で言えば、 <code>year</code> や <code>day</code> は非終端記号であり、別に構文規則の定義がされます。
一方、 <code>'/'</code> はスラッシュ記号そのものであり、定義はされません。つまり終端記号です。</p><h3 id=構文規則の選択>構文規則の選択<a hidden class=anchor aria-hidden=true href=#構文規則の選択>#</a></h3><p>さて、世の中には同じ記号を複数の構文規則で定義したい場合があります。
例えば、 &ldquo;2017/10/21&rdquo; も &ldquo;2017-10-21&rdquo; も「日付」として扱いたい場合などです。</p><p>この場合、yaccの構文規則では、次のように並べて書くことができます。</p><pre tabindex=0><code>date : year &#39;/&#39; month &#39;/&#39; day ;
date : year &#39;-&#39; month &#39;-&#39; day ;
</code></pre><p>また、バー <code>|</code> を使うことで、より変更しやすく、見やすく書くこともできます。</p><pre tabindex=0><code>date : year &#39;/&#39; month &#39;/&#39; day
     | year &#39;-&#39; month &#39;-&#39; day
     ;
</code></pre><h3 id=再帰的な定義>再帰的な定義<a hidden class=anchor aria-hidden=true href=#再帰的な定義>#</a></h3><p>再帰的に構文規則を定義することで柔軟な文法を定義することができるのも特徴です。
例えば &ldquo;1,2&rdquo; も &ldquo;1,2,3&rdquo; も「リスト」として扱いたいみたいな場合は、次のように定義します。
(item は [0-9]+ とする)</p><pre tabindex=0><code>list : item
     | item list
     ;
</code></pre><p>この規則 2 である <code>item list</code> がミソです。</p><p>まず、規則 1 により、 <code>item</code> は <code>list</code> です。
よって、規則 2 より、<code>item item</code> も <code>list</code> になります。
よって、規則 2 より、<code>item item item</code> も <code>list</code> になります。
と、このように、再帰的に定義が可能となります。</p><h3 id=構文規則とアクション>構文規則とアクション<a hidden class=anchor aria-hidden=true href=#構文規則とアクション>#</a></h3><p>構文規則だけを定義し続けても、「だから？」みたいな気分になること請け合いです。
何らかの処理と関連付けないと意味がありません。
yacc では、構文規則とアクションを関連付けることができます。</p><p>アクションは任意の C のコードで、構文規則の次にブレース <code>{}</code> で囲って定義します。</p><pre tabindex=0><code>A : &#39;(&#39; B &#39;)&#39;
  { foo(47, &#34;bar&#34;) }
  ;
</code></pre><p>文法に基づいて文を解析しやすくするように、アクション中で次の疑似変数を使うことができます。</p><p>アクション中で値を返すためには <code>$$</code> を使います。</p><pre tabindex=0><code>{ $$ = 47; }
</code></pre><p>構成要素から値を取得するためには <code>$1, $2, ...</code> を使います。</p><pre tabindex=0><code>{ printf(&#34;%d\n&#34;, $1); }
</code></pre><p>例を見てみましょう。</p><pre tabindex=0><code>A : B C
  { printf(&#34;%d\n&#34;, ($1 + $2)); }
  ;
B : &#39;,&#39;
  { $$ = 3 }
  ;
C : &#39;.&#39;
  { $$ = 5 }
  ;
</code></pre><p>こちらの定義では、 B が 3 を返し、C が 5 を返します。
返した値は、その定義を使う A で利用でき、A のアクション内では、 <code>$1, $2, ...</code> から使うことができます。
この <code>$</code> の次につく数値は、構文定義の構成要素として現れる順に振られます。
ですので、上記の例では <code>$1</code> が 3 に、 <code>$2</code> が 5 になります。</p><p>これを用いたサンプルを最後に一つお見せしましょう。</p><pre tabindex=0><code>expression : &#39;(&#39; expression &#39;)&#39;
           { $$ = $2 }
</code></pre><p>この定義は次のようになります。</p><blockquote><p>「式」は &lsquo;()&rsquo; でくくっても、「式」</p></blockquote><h3 id=字句解析の定義>字句解析の定義<a hidden class=anchor aria-hidden=true href=#字句解析の定義>#</a></h3><p>最初の方にも書きましたが、一般的なコンパイラでは字句解析器が字句解析をし、
それによって得られた字句の集合を元に構文解析器が構文解析をします。
そして、yacc は構文解析器を作るツールです。</p><p>ですので、yacc は字句解器をする関数 <code>int yylex(void);</code> という関数の実装を要求します。</p><p><code>int yylex(void);</code> はユーザからの入力を字句(token)に分解し、パーサに結果を渡す関数です。
この関数は字句の種類を表す字句番号を整数でで返し、トークンに関連付けられた値がある場合は外部変数の <code>yylval</code> に割り当てます。</p><p>さて、この <code>int yylex(void);</code> は自作可能ですが、少なくとも入門者が自作するのは無謀なので、
字句解析器を作るためのツールである lex を使います。</p><h2 id=字句解析器の生成ツール-lex-との連携>字句解析器の生成ツール lex との連携<a hidden class=anchor aria-hidden=true href=#字句解析器の生成ツール-lex-との連携>#</a></h2><p>直前にも書きましたが、yacc は字句解器をする関数 <code>int yylex(void);</code> という関数の実装を要求します。
そして、その関数は自作可能ですが、入門者ならば lex を使い自動生成した方が簡単です。</p><p>lex は字句解析器を作るためのツールです。</p><p>lex も yacc と似ており、字句解析器の定義ファイルを lex に渡してやることで、
字句解析器の C ソースファイル(デフォルトでは <code>lex.yy.c</code> )が作成されます。</p><pre tabindex=0><code>$ ls
minimal.l
$ lex minimal.l
$ ls
minimal.l lex.yy.c
</code></pre><p>また、定義ファイルの構成も似ており、宣言部、定義部、プログラム部の 3 部で構成され、それぞれ <code>%%</code> で区切られます。</p><pre tabindex=0><code class=language-yacc data-lang=yacc>/* 宣言部 */
%%
/* 定義部 */
%%
/* プログラム部 */
</code></pre><p>lex で定義するのは字句解析器向けのルールになるので、定義部は yacc で用いる定義ファイルと異なります。
lex で定義する字句解析ルールの書き方は簡単で、まずマッチさせるための正規表現を書き、次にアクションを書くだけです。
アクションは C のプログラムコードで書き、1文ならそのまま、2文以上なら <code>{}</code> で囲んで書きます。</p><p>サンプルとして、単語数を数える字句解析器のコードを見ながら説明しましょう。</p><pre tabindex=0><code class=language-lex:mywc.l data-lang=lex:mywc.l>%option noyywrap
%{
  int num_lines = 0, num_words = 0, num_chars = 0;
%}
%%

\n { ++num_lines; }
[a-zA-Z0-9]* { ++num_words; }
. { ++num_chars; }

%%

int main(void) {
  yylex();
  printf(&#34;# of lines = %d, # of words = %d # of chars = %d\n&#34;, num_lines, num_words, num_chars);
}
</code></pre><p>この定義ファイルを元に字句解析器を作り、動かしてみると(精度はイマイチですが)きちんと動くのがわかるかと思います。</p><pre tabindex=0><code>$ lex mywc.l
$ cc lex.yy.c
$ cat mywc.l | ./a.out
# of lines = 17, # of words = 42 # of chars = 133
</code></pre><p>さて、この lex を使って yacc 向けの <code>int yylex(void);</code> 関数を実装するわけですが、
この時、上記に示した lex 単体で動くプログラム、 <code>mywc.l</code> と次の3点を変える必要があります。</p><ol><li>lex 向けのオプション noyywrap を消す (要調査)</li><li>lex のアクションで字句名を返すようにする</li><li>lex と yacc で同じ字句名を使えるように、 lex 側で y.tab.h (yacc の生成するヘッダ) を読み込む</li></ol><p>サンプルとして、入力中から日付だけを抜き出すプログラムを作ってみましょう。</p><p>まずは作業用ディレクトリを用意します。</p><pre tabindex=0><code>$ mkdir datefinder
$ cd datefinder
</code></pre><p>次に、字句解析器の定義を作っていきます。
字句解析器は、与えられた文字列を、字句ごとにバラバラにするのが目的です。
今回は、与えられた文字列を、「年」「月」「日」「それ以外」に分解していきましょう。</p><p>なお、簡単にするために「月」は英語の省略形 (例えば &lsquo;Jan&rsquo;) のみを認めることにします。</p><pre tabindex=0><code class=language-lex:datefinder.l data-lang=lex:datefinder.l>%%



%%
</code></pre><h2 id=もう少しマシな解析器---加算器>もう少しマシな解析器 - 加算器<a hidden class=anchor aria-hidden=true href=#もう少しマシな解析器---加算器>#</a></h2><p>yacc の詳細を探りながら、次の話に進みましょう。</p><h3 id=加算減算器の実装>加算・減算器の実装<a hidden class=anchor aria-hidden=true href=#加算減算器の実装>#</a></h3><h3 id=lex-との連携>lex との連携<a hidden class=anchor aria-hidden=true href=#lex-との連携>#</a></h3></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ayasuda.github.io/pages/challenge_aoc2019_day5/><span class=title>« Prev</span><br><span>クリスマスはとっくに終わったけど、俺は AoC をただ解いていこうと思う。5 日目</span></a>
<a class=next href=https://ayasuda.github.io/pages/what_is_spring_context/><span class=title>Next »</span><br><span>これはタイトルです</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share これはタイトルです on twitter" href="https://twitter.com/intent/tweet/?text=%e3%81%93%e3%82%8c%e3%81%af%e3%82%bf%e3%82%a4%e3%83%88%e3%83%ab%e3%81%a7%e3%81%99&url=https%3a%2f%2fayasuda.github.io%2fpages%2fintroduction_yacc%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share これはタイトルです on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fayasuda.github.io%2fpages%2fintroduction_yacc%2f&title=%e3%81%93%e3%82%8c%e3%81%af%e3%82%bf%e3%82%a4%e3%83%88%e3%83%ab%e3%81%a7%e3%81%99&summary=%e3%81%93%e3%82%8c%e3%81%af%e3%82%bf%e3%82%a4%e3%83%88%e3%83%ab%e3%81%a7%e3%81%99&source=https%3a%2f%2fayasuda.github.io%2fpages%2fintroduction_yacc%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share これはタイトルです on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fayasuda.github.io%2fpages%2fintroduction_yacc%2f&title=%e3%81%93%e3%82%8c%e3%81%af%e3%82%bf%e3%82%a4%e3%83%88%e3%83%ab%e3%81%a7%e3%81%99"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share これはタイトルです on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fayasuda.github.io%2fpages%2fintroduction_yacc%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share これはタイトルです on whatsapp" href="https://api.whatsapp.com/send?text=%e3%81%93%e3%82%8c%e3%81%af%e3%82%bf%e3%82%a4%e3%83%88%e3%83%ab%e3%81%a7%e3%81%99%20-%20https%3a%2f%2fayasuda.github.io%2fpages%2fintroduction_yacc%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share これはタイトルです on telegram" href="https://telegram.me/share/url?text=%e3%81%93%e3%82%8c%e3%81%af%e3%82%bf%e3%82%a4%e3%83%88%e3%83%ab%e3%81%a7%e3%81%99&url=https%3a%2f%2fayasuda.github.io%2fpages%2fintroduction_yacc%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://ayasuda.github.io>ayasuda.github.io</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>