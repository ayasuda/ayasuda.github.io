<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>これはタイトルです | ayasuda.github.io</title><meta name=keywords content><meta name=description content="俺のための yacc 入門 いつか何もかも忘れる自分に向けて。 この文書では、yacc って何？ 美味しいの？ みたいなプログラマ、そうオレをターゲットに、 ステ"><meta name=author content="ayasuda"><link rel=canonical href=https://ayasuda.github.io/pages/introduction_yacc/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ayasuda.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ayasuda.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ayasuda.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ayasuda.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ayasuda.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-138223597-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="これはタイトルです"><meta property="og:description" content="俺のための yacc 入門 いつか何もかも忘れる自分に向けて。 この文書では、yacc って何？ 美味しいの？ みたいなプログラマ、そうオレをターゲットに、 ステ"><meta property="og:type" content="article"><meta property="og:url" content="https://ayasuda.github.io/pages/introduction_yacc/"><meta property="article:section" content="pages"><meta property="og:site_name" content="ayasuda.gihtub.io"><meta name=twitter:card content="summary"><meta name=twitter:title content="これはタイトルです"><meta name=twitter:description content="俺のための yacc 入門 いつか何もかも忘れる自分に向けて。 この文書では、yacc って何？ 美味しいの？ みたいなプログラマ、そうオレをターゲットに、 ステ"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Pages","item":"https://ayasuda.github.io/pages/"},{"@type":"ListItem","position":3,"name":"これはタイトルです","item":"https://ayasuda.github.io/pages/introduction_yacc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"これはタイトルです","name":"これはタイトルです","description":"俺のための yacc 入門 いつか何もかも忘れる自分に向けて。 この文書では、yacc って何？ 美味しいの？ みたいなプログラマ、そうオレをターゲットに、 ステ","keywords":[],"articleBody":"俺のための yacc 入門 いつか何もかも忘れる自分に向けて。\nこの文書では、yacc って何？　美味しいの？　みたいなプログラマ、そうオレをターゲットに、 ステップバイステップで yacc の使い方 について学んでいく。\nyacc yacc (yet another compiler compiler) は構文解析器を作るためのツールです。\n構文解析器って何よ？ 大雑把に言えばプログラミング言語みたいな一定のルールを守った言語のことを 「 形式言語 」と呼びます。 そんな形式言語で書かれた文書を元に、構文木を作るツールが構文解析器です。\n一般的に、コンパイラは字句解析器 (lexical analyzer, lexier) が字句解析をし、字句の列を作ります。 次に構文解析器 (parser) が字句の列を元に、構文木を作ります。 そして、最後にその構文木を元に計算を行う奴がいたり、もしくは実行可能なマシン語に変換する奴がいたりします。\nyacc はこの構文解析器を作るためのツールになります。\n準備 まずは yacc または、bison をインストールしましょう。\nインストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。\n$ yacc --version bison (GNU Bison) 2.3 Written by Robert Corbett and Richard Stallman. Copyright (C) 2006 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. また、 yacc は定義ファイルを元に C のコードを生成します。 ですので、 C のコンパイラをインストールしておく必要があります。\nインストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。\n$ cc --version Apple LLVM version 8.0.0 (clang-800.0.42.1) Target: x86_64-apple-darwin15.6.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin あとあと、どうせ使うことになるので lex または flex もインストールしておきます。 lex は字句解析器を作るためのツールとなります。 インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。\n$ lex --version flex 2.5.35 Apple(flex-31) ついでに make もインストールしておくと便利です。 インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。\n$ make --version GNU Make 3.81 Copyright (C) 2006 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. This program built for i386-apple-darwin11.3.0 初めての(何も起きない)構文解析器 - まずはいつもの Hello,World. から まずは作業用のディレクトリを作り、そこに移動しましょう。\n$ mkdir minimal $ cd minimal 早速、“Hello, World.” と表示されるだけのプログラムを書いてみましょう。 構文解析器の定義ファイルである minimal.y を次のように書きます。\n%{ #include int yyerror(const char *s); int yylex(void); %} %% PROGRAM : ; %% int main() { yyparse(); printf(\"Hello, World.\\n\"); return 0; } int yyerror(const char *s) { return 0; } int yylex(void) { return 0; } 書けたら早速動かしてみましょう。まずは yacc を用いて C のコードを生成します。 この時、何も指定しなければ y.tab.c というファイルが生成されるはずです。 次に、この C のコードをコンパイルして実行可能にします。 コンパイルができたら、動かしてみて、 “Hello,World.” と表示されるのを確認しましょう。\n$ yacc minimal.y $ cc y.tab.c $ ./a.out Hello, World. 定義ファイルの構造 yacc で用いる定義ファイルは宣言部、定義部、プログラム部の 3 部で構成され、それぞれ %% で区切られます。\n/* 宣言部 */ %% /* 定義部 */ %% /* プログラム部 */ このうち、宣言部及びプログラム部は省略が可能です。\n宣言部では使用する字句の宣言や全体で使う C の対局変数定義、関数の宣言などを行います。 定義部には構文解析で用いる、構文規則(文法の定義)を、そしてプログラム部では C の関数実装などを行います。\n先ほど作った minimal.y を見ていきましょう。\n宣言部では、全体で使うために stdio.h のインクルードをしています。 定義部には構文規則が書かれておりますが、今回は特に使わないので意味のない文法が定義されています。 最後にプログラム部ではエントリーポイントである main 関数及び、 yacc が字句解析のために要求する yylex 関数、 そしてエラー処理のために要求する yyerror 関数の実装が書かれています。\n定義ファイルの書き方 構文規則 定義部には構文解析に用いる構文規則を書いていきます。 構文規則は以下の形式で定義します。\na : body ; ここで、 a は文法の名前(非終端記号)で、 body はそれの構成要素です。 具体例として、「日付」の定義を見てみましょう。\ndate : year '/' month '/' day ; この構文規則では、次のような書式を「日付」として扱うと定義しています。\n「日付」は、まず「年」があり、次に ‘/’ があり、次に「月」があり、次に ‘/’ があり、最後に「日」が書かれている物である\nこのような構文規則を定義することで、例えば “2017/10/21” のような文字列が「日付」として処理されるようになります。\nところで、上記のような定義を見ると、year とか、 month とかも構文規則が必要になることに気づくかと思います。 その通りで、どんどんどんどん構文規則を定義していくと、最後は「文字」とか、「記号」とかのレベルまで分解可能です。 逆に言えば、「文字」とか「記号」とかは特に定義をする必要がありません。このように、構文規則の右側にのみ現れる記号を 「終端記号」といい、構文規則として定義される記号を「非終端記号」と呼びます。 「日付」の例で言えば、 year や day は非終端記号であり、別に構文規則の定義がされます。 一方、 '/' はスラッシュ記号そのものであり、定義はされません。つまり終端記号です。\n構文規則の選択 さて、世の中には同じ記号を複数の構文規則で定義したい場合があります。 例えば、 “2017/10/21” も “2017-10-21” も「日付」として扱いたい場合などです。\nこの場合、yaccの構文規則では、次のように並べて書くことができます。\ndate : year '/' month '/' day ; date : year '-' month '-' day ; また、バー | を使うことで、より変更しやすく、見やすく書くこともできます。\ndate : year '/' month '/' day | year '-' month '-' day ; 再帰的な定義 再帰的に構文規則を定義することで柔軟な文法を定義することができるのも特徴です。 例えば “1,2” も “1,2,3” も「リスト」として扱いたいみたいな場合は、次のように定義します。 (item は [0-9]+ とする)\nlist : item | item list ; この規則 2 である item list がミソです。\nまず、規則 1 により、 item は list です。 よって、規則 2 より、item item も list になります。 よって、規則 2 より、item item item も list になります。 と、このように、再帰的に定義が可能となります。\n構文規則とアクション 構文規則だけを定義し続けても、「だから？」みたいな気分になること請け合いです。 何らかの処理と関連付けないと意味がありません。 yacc では、構文規則とアクションを関連付けることができます。\nアクションは任意の C のコードで、構文規則の次にブレース {} で囲って定義します。\nA : '(' B ')' { foo(47, \"bar\") } ; 文法に基づいて文を解析しやすくするように、アクション中で次の疑似変数を使うことができます。\nアクション中で値を返すためには $$ を使います。\n{ $$ = 47; } 構成要素から値を取得するためには $1, $2, ... を使います。\n{ printf(\"%d\\n\", $1); } 例を見てみましょう。\nA : B C { printf(\"%d\\n\", ($1 + $2)); } ; B : ',' { $$ = 3 } ; C : '.' { $$ = 5 } ; こちらの定義では、 B が 3 を返し、C が 5 を返します。 返した値は、その定義を使う A で利用でき、A のアクション内では、 $1, $2, ... から使うことができます。 この $ の次につく数値は、構文定義の構成要素として現れる順に振られます。 ですので、上記の例では $1 が 3 に、 $2 が 5 になります。\nこれを用いたサンプルを最後に一つお見せしましょう。\nexpression : '(' expression ')' { $$ = $2 } この定義は次のようになります。\n「式」は ‘()’ でくくっても、「式」\n字句解析の定義 最初の方にも書きましたが、一般的なコンパイラでは字句解析器が字句解析をし、 それによって得られた字句の集合を元に構文解析器が構文解析をします。 そして、yacc は構文解析器を作るツールです。\nですので、yacc は字句解器をする関数 int yylex(void); という関数の実装を要求します。\nint yylex(void); はユーザからの入力を字句(token)に分解し、パーサに結果を渡す関数です。 この関数は字句の種類を表す字句番号を整数でで返し、トークンに関連付けられた値がある場合は外部変数の yylval に割り当てます。\nさて、この int yylex(void); は自作可能ですが、少なくとも入門者が自作するのは無謀なので、 字句解析器を作るためのツールである lex を使います。\n字句解析器の生成ツール lex との連携 直前にも書きましたが、yacc は字句解器をする関数 int yylex(void); という関数の実装を要求します。 そして、その関数は自作可能ですが、入門者ならば lex を使い自動生成した方が簡単です。\nlex は字句解析器を作るためのツールです。\nlex も yacc と似ており、字句解析器の定義ファイルを lex に渡してやることで、 字句解析器の C ソースファイル(デフォルトでは lex.yy.c )が作成されます。\n$ ls minimal.l $ lex minimal.l $ ls minimal.l lex.yy.c また、定義ファイルの構成も似ており、宣言部、定義部、プログラム部の 3 部で構成され、それぞれ %% で区切られます。\n/* 宣言部 */ %% /* 定義部 */ %% /* プログラム部 */ lex で定義するのは字句解析器向けのルールになるので、定義部は yacc で用いる定義ファイルと異なります。 lex で定義する字句解析ルールの書き方は簡単で、まずマッチさせるための正規表現を書き、次にアクションを書くだけです。 アクションは C のプログラムコードで書き、1文ならそのまま、2文以上なら {} で囲んで書きます。\nサンプルとして、単語数を数える字句解析器のコードを見ながら説明しましょう。\n%option noyywrap %{ int num_lines = 0, num_words = 0, num_chars = 0; %} %% \\n { ++num_lines; } [a-zA-Z0-9]* { ++num_words; } . { ++num_chars; } %% int main(void) { yylex(); printf(\"# of lines = %d, # of words = %d # of chars = %d\\n\", num_lines, num_words, num_chars); } この定義ファイルを元に字句解析器を作り、動かしてみると(精度はイマイチですが)きちんと動くのがわかるかと思います。\n$ lex mywc.l $ cc lex.yy.c $ cat mywc.l | ./a.out # of lines = 17, # of words = 42 # of chars = 133 さて、この lex を使って yacc 向けの int yylex(void); 関数を実装するわけですが、 この時、上記に示した lex 単体で動くプログラム、 mywc.l と次の3点を変える必要があります。\nlex 向けのオプション noyywrap を消す (要調査) lex のアクションで字句名を返すようにする lex と yacc で同じ字句名を使えるように、 lex 側で y.tab.h (yacc の生成するヘッダ) を読み込む サンプルとして、入力中から日付だけを抜き出すプログラムを作ってみましょう。\nまずは作業用ディレクトリを用意します。\n$ mkdir datefinder $ cd datefinder 次に、字句解析器の定義を作っていきます。 字句解析器は、与えられた文字列を、字句ごとにバラバラにするのが目的です。 今回は、与えられた文字列を、「年」「月」「日」「それ以外」に分解していきましょう。\nなお、簡単にするために「月」は英語の省略形 (例えば ‘Jan’) のみを認めることにします。\n%% %% もう少しマシな解析器 - 加算器 yacc の詳細を探りながら、次の話に進みましょう。\n加算・減算器の実装 lex との連携 ","wordCount":"4133","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"ayasuda"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ayasuda.github.io/pages/introduction_yacc/"},"publisher":{"@type":"Organization","name":"ayasuda.github.io","logo":{"@type":"ImageObject","url":"https://ayasuda.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ayasuda.github.io accesskey=h title="ayasuda.github.io (Alt + H)">ayasuda.github.io</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ayasuda.github.io/pages/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ayasuda.github.io>Home</a>&nbsp;»&nbsp;<a href=https://ayasuda.github.io/pages/>Pages</a></div><h1 class=post-title>これはタイトルです</h1><div class=post-meta>9 min&nbsp;·&nbsp;4133 words&nbsp;·&nbsp;ayasuda</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#yacc>yacc</a><ul><li><a href=#構文解析器って何よ>構文解析器って何よ？</a></li><li><a href=#準備>準備</a></li></ul></li><li><a href=#初めての何も起きない構文解析器---まずはいつもの-helloworld-から>初めての(何も起きない)構文解析器 - まずはいつもの Hello,World. から</a><ul><li><a href=#定義ファイルの構造>定義ファイルの構造</a></li></ul></li><li><a href=#定義ファイルの書き方>定義ファイルの書き方</a><ul><li><a href=#構文規則>構文規則</a></li><li><a href=#構文規則の選択>構文規則の選択</a></li><li><a href=#再帰的な定義>再帰的な定義</a></li><li><a href=#構文規則とアクション>構文規則とアクション</a></li><li><a href=#字句解析の定義>字句解析の定義</a></li></ul></li><li><a href=#字句解析器の生成ツール-lex-との連携>字句解析器の生成ツール lex との連携</a></li><li><a href=#もう少しマシな解析器---加算器>もう少しマシな解析器 - 加算器</a><ul><li><a href=#加算減算器の実装>加算・減算器の実装</a></li><li><a href=#lex-との連携>lex との連携</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=俺のための-yacc-入門>俺のための yacc 入門<a hidden class=anchor aria-hidden=true href=#俺のための-yacc-入門>#</a></h1><p>いつか何もかも忘れる自分に向けて。</p><p>この文書では、<em>yacc って何？　美味しいの？　みたいなプログラマ、そうオレをターゲットに、
ステップバイステップで yacc の使い方</em> について学んでいく。</p><h2 id=yacc>yacc<a hidden class=anchor aria-hidden=true href=#yacc>#</a></h2><p>yacc (yet another compiler compiler) は構文解析器を作るためのツールです。</p><h3 id=構文解析器って何よ>構文解析器って何よ？<a hidden class=anchor aria-hidden=true href=#構文解析器って何よ>#</a></h3><p>大雑把に言えばプログラミング言語みたいな一定のルールを守った言語のことを
「 <a href=https://ja.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E8%A8%80%E8%AA%9E>形式言語</a> 」と呼びます。
そんな形式言語で書かれた文書を元に、構文木を作るツールが構文解析器です。</p><p>一般的に、コンパイラは字句解析器 (lexical analyzer, lexier) が字句解析をし、字句の列を作ります。
次に構文解析器 (parser) が字句の列を元に、構文木を作ります。
そして、最後にその構文木を元に計算を行う奴がいたり、もしくは実行可能なマシン語に変換する奴がいたりします。</p><p>yacc はこの構文解析器を作るためのツールになります。</p><h3 id=準備>準備<a hidden class=anchor aria-hidden=true href=#準備>#</a></h3><p>まずは yacc または、bison をインストールしましょう。</p><p>インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。</p><pre tabindex=0><code>$ yacc --version
bison (GNU Bison) 2.3
Written by Robert Corbett and Richard Stallman.

Copyright (C) 2006 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre><p>また、 yacc は定義ファイルを元に C のコードを生成します。
ですので、 C のコンパイラをインストールしておく必要があります。</p><p>インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。</p><pre tabindex=0><code>$ cc --version
Apple LLVM version 8.0.0 (clang-800.0.42.1)
Target: x86_64-apple-darwin15.6.0
Thread model: posix
InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
</code></pre><p>あとあと、どうせ使うことになるので lex または flex もインストールしておきます。
lex は字句解析器を作るためのツールとなります。
インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。</p><pre tabindex=0><code>$ lex --version
flex 2.5.35 Apple(flex-31)
</code></pre><p>ついでに make もインストールしておくと便利です。
インストールされていれば、下記のコマンドでバージョン番号などが確認できるはずです。</p><pre tabindex=0><code>$ make --version
GNU Make 3.81
Copyright (C) 2006  Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.

This program built for i386-apple-darwin11.3.0
</code></pre><h2 id=初めての何も起きない構文解析器---まずはいつもの-helloworld-から>初めての(何も起きない)構文解析器 - まずはいつもの Hello,World. から<a hidden class=anchor aria-hidden=true href=#初めての何も起きない構文解析器---まずはいつもの-helloworld-から>#</a></h2><p>まずは作業用のディレクトリを作り、そこに移動しましょう。</p><pre tabindex=0><code>$ mkdir minimal
$ cd minimal
</code></pre><p>早速、&ldquo;Hello, World.&rdquo; と表示されるだけのプログラムを書いてみましょう。
構文解析器の定義ファイルである minimal.y を次のように書きます。</p><pre tabindex=0><code class=language-yacc:minimal.y data-lang=yacc:minimal.y>%{
#include &lt;stdio.h&gt;
int yyerror(const char *s);
int yylex(void);
%}

%%

PROGRAM : ;

%%

int main()
{
  yyparse();
  printf(&#34;Hello, World.\n&#34;);
  return 0;
}
int yyerror(const char *s) { return 0; }
int yylex(void) { return 0; }
</code></pre><p>書けたら早速動かしてみましょう。まずは yacc を用いて C のコードを生成します。
この時、何も指定しなければ <code>y.tab.c</code> というファイルが生成されるはずです。
次に、この C のコードをコンパイルして実行可能にします。
コンパイルができたら、動かしてみて、 &ldquo;Hello,World.&rdquo; と表示されるのを確認しましょう。</p><pre tabindex=0><code>$ yacc minimal.y
$ cc y.tab.c
$ ./a.out
Hello, World.
</code></pre><h3 id=定義ファイルの構造>定義ファイルの構造<a hidden class=anchor aria-hidden=true href=#定義ファイルの構造>#</a></h3><p>yacc で用いる定義ファイルは宣言部、定義部、プログラム部の 3 部で構成され、それぞれ <code>%%</code> で区切られます。</p><pre tabindex=0><code class=language-yacc data-lang=yacc>/* 宣言部 */
%%
/* 定義部 */
%%
/* プログラム部 */
</code></pre><p>このうち、宣言部及びプログラム部は省略が可能です。</p><p>宣言部では使用する字句の宣言や全体で使う C の対局変数定義、関数の宣言などを行います。
定義部には構文解析で用いる、構文規則(文法の定義)を、そしてプログラム部では C の関数実装などを行います。</p><p>先ほど作った <code>minimal.y</code> を見ていきましょう。</p><p>宣言部では、全体で使うために <code>stdio.h</code> のインクルードをしています。
定義部には構文規則が書かれておりますが、今回は特に使わないので意味のない文法が定義されています。
最後にプログラム部ではエントリーポイントである <code>main</code> 関数及び、
yacc が字句解析のために要求する <code>yylex</code> 関数、
そしてエラー処理のために要求する <code>yyerror</code> 関数の実装が書かれています。</p><h2 id=定義ファイルの書き方>定義ファイルの書き方<a hidden class=anchor aria-hidden=true href=#定義ファイルの書き方>#</a></h2><h3 id=構文規則>構文規則<a hidden class=anchor aria-hidden=true href=#構文規則>#</a></h3><p>定義部には構文解析に用いる構文規則を書いていきます。
構文規則は以下の形式で定義します。</p><pre tabindex=0><code>a : body ;
</code></pre><p>ここで、 a は文法の名前(非終端記号)で、 body はそれの構成要素です。
具体例として、「日付」の定義を見てみましょう。</p><pre tabindex=0><code>date : year &#39;/&#39; month &#39;/&#39; day ;
</code></pre><p>この構文規則では、次のような書式を「日付」として扱うと定義しています。</p><blockquote><p>「日付」は、まず「年」があり、次に &lsquo;/&rsquo; があり、次に「月」があり、次に &lsquo;/&rsquo; があり、最後に「日」が書かれている物である</p></blockquote><p>このような構文規則を定義することで、例えば &ldquo;2017/10/21&rdquo; のような文字列が「日付」として処理されるようになります。</p><p>ところで、上記のような定義を見ると、<code>year</code> とか、 <code>month</code> とかも構文規則が必要になることに気づくかと思います。
その通りで、どんどんどんどん構文規則を定義していくと、最後は「文字」とか、「記号」とかのレベルまで分解可能です。
逆に言えば、「文字」とか「記号」とかは特に定義をする必要がありません。このように、構文規則の右側にのみ現れる記号を
「終端記号」といい、構文規則として定義される記号を「非終端記号」と呼びます。
「日付」の例で言えば、 <code>year</code> や <code>day</code> は非終端記号であり、別に構文規則の定義がされます。
一方、 <code>'/'</code> はスラッシュ記号そのものであり、定義はされません。つまり終端記号です。</p><h3 id=構文規則の選択>構文規則の選択<a hidden class=anchor aria-hidden=true href=#構文規則の選択>#</a></h3><p>さて、世の中には同じ記号を複数の構文規則で定義したい場合があります。
例えば、 &ldquo;2017/10/21&rdquo; も &ldquo;2017-10-21&rdquo; も「日付」として扱いたい場合などです。</p><p>この場合、yaccの構文規則では、次のように並べて書くことができます。</p><pre tabindex=0><code>date : year &#39;/&#39; month &#39;/&#39; day ;
date : year &#39;-&#39; month &#39;-&#39; day ;
</code></pre><p>また、バー <code>|</code> を使うことで、より変更しやすく、見やすく書くこともできます。</p><pre tabindex=0><code>date : year &#39;/&#39; month &#39;/&#39; day
     | year &#39;-&#39; month &#39;-&#39; day
     ;
</code></pre><h3 id=再帰的な定義>再帰的な定義<a hidden class=anchor aria-hidden=true href=#再帰的な定義>#</a></h3><p>再帰的に構文規則を定義することで柔軟な文法を定義することができるのも特徴です。
例えば &ldquo;1,2&rdquo; も &ldquo;1,2,3&rdquo; も「リスト」として扱いたいみたいな場合は、次のように定義します。
(item は [0-9]+ とする)</p><pre tabindex=0><code>list : item
     | item list
     ;
</code></pre><p>この規則 2 である <code>item list</code> がミソです。</p><p>まず、規則 1 により、 <code>item</code> は <code>list</code> です。
よって、規則 2 より、<code>item item</code> も <code>list</code> になります。
よって、規則 2 より、<code>item item item</code> も <code>list</code> になります。
と、このように、再帰的に定義が可能となります。</p><h3 id=構文規則とアクション>構文規則とアクション<a hidden class=anchor aria-hidden=true href=#構文規則とアクション>#</a></h3><p>構文規則だけを定義し続けても、「だから？」みたいな気分になること請け合いです。
何らかの処理と関連付けないと意味がありません。
yacc では、構文規則とアクションを関連付けることができます。</p><p>アクションは任意の C のコードで、構文規則の次にブレース <code>{}</code> で囲って定義します。</p><pre tabindex=0><code>A : &#39;(&#39; B &#39;)&#39;
  { foo(47, &#34;bar&#34;) }
  ;
</code></pre><p>文法に基づいて文を解析しやすくするように、アクション中で次の疑似変数を使うことができます。</p><p>アクション中で値を返すためには <code>$$</code> を使います。</p><pre tabindex=0><code>{ $$ = 47; }
</code></pre><p>構成要素から値を取得するためには <code>$1, $2, ...</code> を使います。</p><pre tabindex=0><code>{ printf(&#34;%d\n&#34;, $1); }
</code></pre><p>例を見てみましょう。</p><pre tabindex=0><code>A : B C
  { printf(&#34;%d\n&#34;, ($1 + $2)); }
  ;
B : &#39;,&#39;
  { $$ = 3 }
  ;
C : &#39;.&#39;
  { $$ = 5 }
  ;
</code></pre><p>こちらの定義では、 B が 3 を返し、C が 5 を返します。
返した値は、その定義を使う A で利用でき、A のアクション内では、 <code>$1, $2, ...</code> から使うことができます。
この <code>$</code> の次につく数値は、構文定義の構成要素として現れる順に振られます。
ですので、上記の例では <code>$1</code> が 3 に、 <code>$2</code> が 5 になります。</p><p>これを用いたサンプルを最後に一つお見せしましょう。</p><pre tabindex=0><code>expression : &#39;(&#39; expression &#39;)&#39;
           { $$ = $2 }
</code></pre><p>この定義は次のようになります。</p><blockquote><p>「式」は &lsquo;()&rsquo; でくくっても、「式」</p></blockquote><h3 id=字句解析の定義>字句解析の定義<a hidden class=anchor aria-hidden=true href=#字句解析の定義>#</a></h3><p>最初の方にも書きましたが、一般的なコンパイラでは字句解析器が字句解析をし、
それによって得られた字句の集合を元に構文解析器が構文解析をします。
そして、yacc は構文解析器を作るツールです。</p><p>ですので、yacc は字句解器をする関数 <code>int yylex(void);</code> という関数の実装を要求します。</p><p><code>int yylex(void);</code> はユーザからの入力を字句(token)に分解し、パーサに結果を渡す関数です。
この関数は字句の種類を表す字句番号を整数でで返し、トークンに関連付けられた値がある場合は外部変数の <code>yylval</code> に割り当てます。</p><p>さて、この <code>int yylex(void);</code> は自作可能ですが、少なくとも入門者が自作するのは無謀なので、
字句解析器を作るためのツールである lex を使います。</p><h2 id=字句解析器の生成ツール-lex-との連携>字句解析器の生成ツール lex との連携<a hidden class=anchor aria-hidden=true href=#字句解析器の生成ツール-lex-との連携>#</a></h2><p>直前にも書きましたが、yacc は字句解器をする関数 <code>int yylex(void);</code> という関数の実装を要求します。
そして、その関数は自作可能ですが、入門者ならば lex を使い自動生成した方が簡単です。</p><p>lex は字句解析器を作るためのツールです。</p><p>lex も yacc と似ており、字句解析器の定義ファイルを lex に渡してやることで、
字句解析器の C ソースファイル(デフォルトでは <code>lex.yy.c</code> )が作成されます。</p><pre tabindex=0><code>$ ls
minimal.l
$ lex minimal.l
$ ls
minimal.l lex.yy.c
</code></pre><p>また、定義ファイルの構成も似ており、宣言部、定義部、プログラム部の 3 部で構成され、それぞれ <code>%%</code> で区切られます。</p><pre tabindex=0><code class=language-yacc data-lang=yacc>/* 宣言部 */
%%
/* 定義部 */
%%
/* プログラム部 */
</code></pre><p>lex で定義するのは字句解析器向けのルールになるので、定義部は yacc で用いる定義ファイルと異なります。
lex で定義する字句解析ルールの書き方は簡単で、まずマッチさせるための正規表現を書き、次にアクションを書くだけです。
アクションは C のプログラムコードで書き、1文ならそのまま、2文以上なら <code>{}</code> で囲んで書きます。</p><p>サンプルとして、単語数を数える字句解析器のコードを見ながら説明しましょう。</p><pre tabindex=0><code class=language-lex:mywc.l data-lang=lex:mywc.l>%option noyywrap
%{
  int num_lines = 0, num_words = 0, num_chars = 0;
%}
%%

\n { ++num_lines; }
[a-zA-Z0-9]* { ++num_words; }
. { ++num_chars; }

%%

int main(void) {
  yylex();
  printf(&#34;# of lines = %d, # of words = %d # of chars = %d\n&#34;, num_lines, num_words, num_chars);
}
</code></pre><p>この定義ファイルを元に字句解析器を作り、動かしてみると(精度はイマイチですが)きちんと動くのがわかるかと思います。</p><pre tabindex=0><code>$ lex mywc.l
$ cc lex.yy.c
$ cat mywc.l | ./a.out
# of lines = 17, # of words = 42 # of chars = 133
</code></pre><p>さて、この lex を使って yacc 向けの <code>int yylex(void);</code> 関数を実装するわけですが、
この時、上記に示した lex 単体で動くプログラム、 <code>mywc.l</code> と次の3点を変える必要があります。</p><ol><li>lex 向けのオプション noyywrap を消す (要調査)</li><li>lex のアクションで字句名を返すようにする</li><li>lex と yacc で同じ字句名を使えるように、 lex 側で y.tab.h (yacc の生成するヘッダ) を読み込む</li></ol><p>サンプルとして、入力中から日付だけを抜き出すプログラムを作ってみましょう。</p><p>まずは作業用ディレクトリを用意します。</p><pre tabindex=0><code>$ mkdir datefinder
$ cd datefinder
</code></pre><p>次に、字句解析器の定義を作っていきます。
字句解析器は、与えられた文字列を、字句ごとにバラバラにするのが目的です。
今回は、与えられた文字列を、「年」「月」「日」「それ以外」に分解していきましょう。</p><p>なお、簡単にするために「月」は英語の省略形 (例えば &lsquo;Jan&rsquo;) のみを認めることにします。</p><pre tabindex=0><code class=language-lex:datefinder.l data-lang=lex:datefinder.l>%%



%%
</code></pre><h2 id=もう少しマシな解析器---加算器>もう少しマシな解析器 - 加算器<a hidden class=anchor aria-hidden=true href=#もう少しマシな解析器---加算器>#</a></h2><p>yacc の詳細を探りながら、次の話に進みましょう。</p><h3 id=加算減算器の実装>加算・減算器の実装<a hidden class=anchor aria-hidden=true href=#加算減算器の実装>#</a></h3><h3 id=lex-との連携>lex との連携<a hidden class=anchor aria-hidden=true href=#lex-との連携>#</a></h3></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ayasuda.github.io/pages/challenge_aoc2019_day5/><span class=title>« Prev</span><br><span>クリスマスはとっくに終わったけど、俺は AoC をただ解いていこうと思う。5 日目</span></a>
<a class=next href=https://ayasuda.github.io/pages/what_is_spring_context/><span class=title>Next »</span><br><span>これはタイトルです</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://ayasuda.github.io>ayasuda.github.io</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>